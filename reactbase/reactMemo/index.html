<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>使用React.memo()来优化函数组件的性能 | 瓜皮伦前端之旅</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.40abc9cc.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.fc8aaca0.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.adb8f932.js" as="script"><link rel="preload" href="/myBlog/assets/js/19.f4aaf826.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.4d3def68.js"><link rel="prefetch" href="/myBlog/assets/js/11.4f1916b4.js"><link rel="prefetch" href="/myBlog/assets/js/12.e510eb90.js"><link rel="prefetch" href="/myBlog/assets/js/13.09727da9.js"><link rel="prefetch" href="/myBlog/assets/js/14.7eb4da1b.js"><link rel="prefetch" href="/myBlog/assets/js/15.e1012694.js"><link rel="prefetch" href="/myBlog/assets/js/16.f5bd2548.js"><link rel="prefetch" href="/myBlog/assets/js/17.aeb64fd0.js"><link rel="prefetch" href="/myBlog/assets/js/18.0ad35386.js"><link rel="prefetch" href="/myBlog/assets/js/20.44c40c8a.js"><link rel="prefetch" href="/myBlog/assets/js/3.1cd0f6c6.js"><link rel="prefetch" href="/myBlog/assets/js/4.f7478058.js"><link rel="prefetch" href="/myBlog/assets/js/5.771aaea5.js"><link rel="prefetch" href="/myBlog/assets/js/6.a5fb572d.js"><link rel="prefetch" href="/myBlog/assets/js/7.0f5a4226.js"><link rel="prefetch" href="/myBlog/assets/js/8.d0e97708.js"><link rel="prefetch" href="/myBlog/assets/js/9.0a4e49b0.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.40abc9cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><!----> <span class="site-name">瓜皮伦前端之旅</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/myBlog/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/myBlog/basic/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/myBlog/reactbase/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/myBlog/nodebase/" class="nav-link">
  Node.js
</a></div><div class="nav-item"><a href="/myBlog/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="https://blog.csdn.net/qq_39341415?spm=1000.2115.3001.5343" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/Down-1998" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/myBlog/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="/myBlog/basic/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/myBlog/reactbase/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/myBlog/nodebase/" class="nav-link">
  Node.js
</a></div><div class="nav-item"><a href="/myBlog/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="https://blog.csdn.net/qq_39341415?spm=1000.2115.3001.5343" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/Down-1998" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/myBlog/reactbase/reactProps/" class="sidebar-link">React中的render props</a></li><li><a href="/myBlog/reactbase/reactMemo/" aria-current="page" class="active sidebar-link">使用React.memo()来优化函数组件的性能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/reactbase/reactMemo/#解决方案-使用react-memo" class="sidebar-link">解决方案: 使用React.memo()</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="使用react-memo-来优化函数组件的性能"><a href="#使用react-memo-来优化函数组件的性能" class="header-anchor">#</a> 使用React.memo()来优化函数组件的性能</h1> <h1 id="无用的渲染"><a href="#无用的渲染" class="header-anchor">#</a> 无用的渲染</h1> <p>组件是构成React视图的一个基本单元。有些组件会有自己本地的状态(state), 当它们的值由于用户的操作而发生改变时，组件就会重新渲染。在一个React应用中，一个组件可能会被频繁地进行渲染。这些渲染虽然有一小部分是必须的，不过大多数都是无用的，它们的存在会大大降低我们应用的性能。</p> <p>看下面这个例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestC</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            count<span class="token operator">:</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentWillUpdate'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentDidUpdate'</span><span class="token punctuation">)</span>
        
    <span class="token punctuation">}</span>
    
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div <span class="token operator">&gt;</span>
            <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>
            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Click Me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> TestC<span class="token punctuation">;</span>

</code></pre></div><p>TestC组件有一个本地状态count，它的初始值是0(state = {count: 0})。当我们点击Click Me按钮时，count的值被设置为1。这时候屏幕的数字将会由0变成1。当我们再次点击该按钮时，count的值还是1, 这时候TestC组件不应该被重新渲染，可是现实却不是这样的。
为了测试count重复设置相同的值组件会不会被重新渲染, 我为TestC组件添加了两个生命周期函数: <strong>componentWillUpdate</strong>和<strong>componentDidUpdate</strong>。<strong>componentWillUpdate</strong>方法在组件将要被重新渲染时被调用，而<strong>componentDidUpdate</strong>方法会在组件成功重渲染后被调用。</p> <p>我们可以看到'componentWillUpdate'和'componentWillUpdate'在每次我们点击完按钮后，都会在控制台输出来。所以即使count被设置相同的值，TestC组件还是会被重新渲染，这些就是所谓的无用渲染。</p> <h1 id="pure-component-shouldcomponentupdate"><a href="#pure-component-shouldcomponentupdate" class="header-anchor">#</a> Pure Component/shouldComponentUpdate</h1> <p>为了避免React组件的无用渲染，我们可以实现自己的<strong>shouldComponentUpdate</strong>生命周期函数。</p> <p>当React想要渲染一个组件的时候，它将会调用这个组件的<strong>shouldComponentUpdate</strong>函数, 这个函数会告诉它是不是真的要渲染这个组件。</p> <p>如果我们的shouldComponentUpdate函数这样写:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>        
<span class="token punctuation">}</span>
</code></pre></div><p>其中各个参数的含义是：</p> <div class="language- extra-class"><pre><code>nextProps: 组件将会接收的下一个参数props
nextProps: 组件的下一个状态state
</code></pre></div><p>因为我们的<strong>shouldComponentUpdate</strong>函数一直返回true，这就告诉React，无论何种情况都要重新渲染该组件。</p> <p>可是如果我们这么写:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为这个方法的返回值是false，所以React永远都不会重新渲染我们的组件。</p> <p>因此当你想要React重新渲染你的组件的时候，就在这个方法中返回true，否则返回false。现在让我们用shouldComponentUpdate重写之前的TestC组件:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestC</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            count<span class="token operator">:</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentWillUpdate'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentDidUpdate'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">===</span> nextState<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span> 
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span> 
            <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token punctuation">}</span> 
            <span class="token operator">&lt;</span>button onClick <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span> Click Me <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span> 
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> TestC<span class="token punctuation">;</span>

</code></pre></div><p>我们在TestC组件里添加了<strong>shouldComponentUpdate</strong>方法，判断如果现在状态的count和下一个状态的count一样时，我们返回false，这样React将不会进行组件的重新渲染，反之，如果它们两个的值不一样，就返回true，这样组件将会重新进行渲染。</p> <p>这时候，就算我们多次点击Click Me按钮，也只能看到两行输出:</p> <div class="language- extra-class"><pre><code>componentWillUpdate
componentDidUpdate 
</code></pre></div><p>因为第二次点击Click Me按钮后count值一直是1，这样<strong>shouldComponentUpdate</strong>一直返回false，所以组件就不再被重新渲染了。</p> <p>那么如何验证后面state的值发生改变，组件还是会被重新渲染呢？我们可以在浏览器的React DevTools插件中直接对TestC组件的状态进行更改。具体做法是, 在Chrome调试工具中点击React标签，在界面左边选中TestC组件，在界面的右边就可以看到其状态state中只有一个键count，且其值是1:</p> <p>然后让我们点击count的值1，将其修改为2，然后按回车键:
你将会看到控制台有以下输出:</p> <div class="language- extra-class"><pre><code>componentWillUpdate
componentDidUpdate
componentWillUpdate
componentDidUpdate
</code></pre></div><p>state的count被改变了，组件也被重新渲染了。</p> <p>现在让我们使用另外一种方法<strong>PureComponent</strong>来对组件进行优化。</p> <p>React在v15.5的时候引入了Pure Component组件。React在进行组件更新时，如果发现这个组件是一个PureComponent，它会将组件现在的state和props和其下一个state和props进行浅比较，如果它们的值没有变化，就不会进行更新。要想让你的组件成为Pure Component，只需要extends React.PureComponent即可。</p> <p>让我们用PureComponent去改写一下我们的代码吧:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestC</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            count<span class="token operator">:</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentWillUpdate'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentDidUpdate'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/*shouldComponentUpdate(nextProps, nextState) {
        if (this.state.count === nextState.count) {
            return false
        }
        return true
    }*/</span>
    
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span> 
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span> 
            <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token punctuation">}</span> 
            <span class="token operator">&lt;</span>button onClick <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token operator">&gt;</span> Click Me <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span> 
            <span class="token operator">&lt;</span><span class="token operator">/</span>div <span class="token operator">&gt;</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> TestC<span class="token punctuation">;</span>

</code></pre></div><p>在上面的代码中，我将shouldComponentUpdate的代码注释掉了，因为React.PureComponent本身就帮我们实现了一样的功能。
改完代码后，我们刷新一下浏览器，然后多次点击Click Me按钮看组件被渲染了多少遍:</p> <div class="language- extra-class"><pre><code>componentWillUpdate
componentDidUpdate
</code></pre></div><p>由上面的输出可知，我们的component只在state由0变为1时被重新渲染了，后面都没有进行渲染。</p> <h1 id="函数组件"><a href="#函数组件" class="header-anchor">#</a> 函数组件</h1> <p>我们探讨了如何使用PureComponent和shouldComponentUpdate的方法优化类组件的性能。虽然类组件是React应用的主要组成部分，不过函数组件(Functional Component)同样可以被作为React组件使用。</p> <h2 id="解决方案-使用react-memo"><a href="#解决方案-使用react-memo" class="header-anchor">#</a> 解决方案: 使用React.memo()</h2> <p>React.memo(...)是React v16.6引进来的新属性。它的作用和React.PureComponent类似，是用来控制函数组件的重新渲染的。React.memo(...) 其实就是函数组件的React.PureComponent。</p> <p><strong>React.memo</strong>会返回一个纯化(purified)的组件MemoFuncComponent，这个组件将会在JSX标记中渲染出来。<strong>当组件的参数props和状态state发生改变时，React将会检查前一个状态和参数是否和下一个状态和参数是否相同，如果相同，组件将不会被渲染，如果不同，组件将会被重新渲染。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">TestC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Rendering TestC :'</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span> 
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span> props<span class="token punctuation">.</span>count <span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
TestC <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>TestC<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在我们之前那个没用到React.memo(...)的例子中，count的重复设置会使组件进行重新渲染。可是我们用了React.memo后，该组件在传入的值不变的前提下是不会被重新渲染的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/myBlog/reactbase/reactProps/" class="prev">
        React中的render props
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.fc8aaca0.js" defer></script><script src="/myBlog/assets/js/2.adb8f932.js" defer></script><script src="/myBlog/assets/js/19.f4aaf826.js" defer></script>
  </body>
</html>
